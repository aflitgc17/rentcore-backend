const express = require("express");
const router = express.Router();

const { authMiddleware, adminOnly } = require("../middleware/auth");
const { PrismaClient } = require("@prisma/client");
const prisma = new PrismaClient();

/**
 * ğŸ”¹ ì‚¬ìš©ì ëŒ€ì—¬ ì‹ ì²­
 * POST /rental-requests
 */
router.post("/", authMiddleware, async (req, res) => {
  try {
    const { from, to, subjectName, purpose, items } = req.body;

    if (!subjectName || !purpose) {
      return res.status(400).json({ message: "ì‚¬ìš© ì •ë³´ ëˆ„ë½" });
    }

    const parsedFrom = new Date(from);
    const parsedTo = new Date(to);

    const rentalRequest = await prisma.rentalRequest.create({
      data: {
        userId: req.user.userId,
        from: parsedFrom,
        to: parsedTo,
        subjectName,
        purpose,
        status: "REQUESTED",
        items: {
          create: items.map(item => ({
            equipmentId: Number(item.equipmentId)
          }))
        }
      }
    });

    res.json(rentalRequest);
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: "ëŒ€ì—¬ ì‹ ì²­ ì‹¤íŒ¨" });
  }
});

/**
 * ğŸ”¹ ê´€ë¦¬ì ì „ì²´ ìš”ì²­ ì¡°íšŒ
 * GET /rental-requests
 */
  router.get("/", authMiddleware, adminOnly, async (req, res) => {
    try {
      const { status } = req.query;

      const requests = await prisma.rentalRequest.findMany({
        where: status ? { status } : {},
        include: {
          user: {
            select: {
              name: true,
              email: true,
            },
          },
          items: {
            include: {
              equipment: true,
            },
          },
        },
        orderBy: { createdAt: "desc" }
      });

      res.json(requests);
    } catch (err) {
      console.error(err);
      res.status(500).json({ message: "ì¡°íšŒ ì‹¤íŒ¨" });
    }
  });

router.post("/conflicts", authMiddleware, async (req, res) => {
  try {
    const { from, to, equipmentIds } = req.body;

    if (!from || !to || !equipmentIds?.length) {
      return res.status(400).json({ message: "ì…ë ¥ê°’ ë¶€ì¡±" });
    }

    const start = new Date(from);
    const end = new Date(to);

     // 1ï¸âƒ£ ì´ë¯¸ ìŠ¹ì¸ëœ ì˜ˆì•½ ê²€ì‚¬
    const approvedConflicts = await prisma.reservationItem.findMany({
      where: {
        equipmentId: { in: equipmentIds.map(Number) },
        reservation: {
          status: "APPROVED",
          startDate: { lt: end },
          endDate: { gt: start },
        },
      },
      select: { equipmentId: true },
    });

    // 2ï¸âƒ£ ì•„ì§ ìŠ¹ì¸ ì•ˆ ëœ ì‹ ì²­ë„ ê²€ì‚¬
    const requestedConflicts = await prisma.rentalItem.findMany({
      where: {
        equipmentId: { in: equipmentIds.map(Number) },
        rentalRequest: {
          status: "REQUESTED",
          from: { lte: end },
          to: { gte: start },
        },
      },
      select: { equipmentId: true },
    });

    // 3ï¸âƒ£ ê²¹ì¹˜ëŠ” ì¥ë¹„ ID í•©ì¹˜ê¸° + ì¤‘ë³µ ì œê±°
    const conflictIds = [
      ...approvedConflicts.map(c => String(c.equipmentId)),
      ...requestedConflicts.map(c => String(c.equipmentId)),
    ];

    const uniqueConflictIds = [...new Set(conflictIds)];

    res.json(uniqueConflictIds);


  } catch (err) {
    console.error("ì¶©ëŒ í™•ì¸ ì—ëŸ¬:", err);
    res.status(500).json({ message: "ì¶©ëŒ í™•ì¸ ì‹¤íŒ¨" });
  }
});



router.patch("/:id/approve", authMiddleware, adminOnly, async (req, res) => {
  try {
    const id = Number(req.params.id);

    const result = await prisma.$transaction(async (tx) => {

      const request = await tx.rentalRequest.findUnique({
      where: { id },
      include: { items: true },
    });

      if (!request)
          throw new Error("ìš”ì²­ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");

      if (request.status !== "REQUESTED")
        throw new Error("ì´ë¯¸ ì²˜ë¦¬ëœ ìš”ì²­ì…ë‹ˆë‹¤.");


      // 1ï¸âƒ£ ì¶©ëŒ ê²€ì‚¬
      for (const item of request.items) {
        const conflict = await tx.reservationItem.findFirst({
          where: {
            equipmentId: item.equipmentId,
            reservation: {
              status: "APPROVED",
              startDate: { lt: request.to },
              endDate: { gt: request.from },
            }
          },
          include: {
            reservation: true
          }
        });

        if (conflict) {
          throw new Error(`ì¥ë¹„ ${item.equipmentId} ëŠ” ì´ë¯¸ ì˜ˆì•½ë˜ì–´ ìˆìŠµë‹ˆë‹¤.`);
        }
      }

      // 2ï¸âƒ£ rentalRequest ìŠ¹ì¸
      const updatedRequest = await tx.rentalRequest.update({
        where: { id },
        data: { status: "APPROVED" },
      });

      // 3ï¸âƒ£ Reservation 1ê±´ ìƒì„±
      const reservation = await tx.reservation.create({
        data: {
          userId: request.userId,
          startDate: request.from,
          endDate: request.to,
          status: "APPROVED",
          subjectName: request.subjectName,
          purpose: request.purpose,
          rentalRequestId: request.id,
          originalRequestCreatedAt: request.createdAt,
        },
      });

      // 4ï¸âƒ£ ReservationItem ì—¬ëŸ¬ ê°œ ìƒì„±
      for (const item of request.items) {
        await tx.reservationItem.create({
          data: {
            reservationId: reservation.id,
            equipmentId: item.equipmentId,
          },
        });
      }

      // 5ï¸âƒ£ ì‚¬ìš©ì ì•Œë¦¼ ìƒì„±
      await tx.notification.create({
        data: {
          userId: request.userId,
          message: `ëŒ€ì—¬ ì‹ ì²­ì´ ìŠ¹ì¸ë˜ì—ˆìŠµë‹ˆë‹¤.`,
          isRead: false,
        },
      });

      return reservation;
    });

    res.json({
      message: "ìŠ¹ì¸ ì™„ë£Œ",
      reservation: result,
    });


  } catch (err) {
    console.error(err);

    if (err.message.includes("ì´ë¯¸ ì˜ˆì•½")) {
      return res.status(400).json({ message: err.message });
    }

    res.status(500).json({ message: "ìŠ¹ì¸ ì‹¤íŒ¨" });

  }
});


router.patch("/:id/reject", authMiddleware, adminOnly, async (req, res) => {
  try {
    const id = Number(req.params.id);
    const { reason } = req.body;

    if (!reason) {
      return res.status(400).json({ message: "ê±°ì ˆ ì‚¬ìœ  í•„ìš”" });
    }

    const request = await prisma.rentalRequest.findUnique({
      where: { id },
    });

    if (!request) {
      return res.status(404).json({ message: "ìš”ì²­ ì—†ìŒ" });
    }

    if (request.status !== "REQUESTED") {
      return res.status(400).json({ message: "ì´ë¯¸ ì²˜ë¦¬ë¨" });
    }

    const updated = await prisma.rentalRequest.update({
      where: { id },
      data: {
        status: "REJECTED",
        rejectionReason: reason,
      },
    });

    // ğŸ”¥ ì•Œë¦¼ ìƒì„±
    await prisma.notification.create({
      data: {
        userId: request.userId,
        message: `ëŒ€ì—¬ ì‹ ì²­ì´ ê±°ì ˆë˜ì—ˆìŠµë‹ˆë‹¤. (ì‚¬ìœ : ${reason})`,
        isRead: false,
      },
    });

    res.json(updated);
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: "ê±°ì ˆ ì‹¤íŒ¨" });
  }
});


module.exports = router;
